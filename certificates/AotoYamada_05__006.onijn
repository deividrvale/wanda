YES
  Signature: [

    branch : [a * b * b] --> b ; 
    leaf : [a] --> b ; 
    mapbt : [a -> a * b] --> b 

  ]

  Rules: [

    mapbt(f, leaf(x)) => leaf(f x) ; 
    mapbt(f, branch(x, y, z)) => branch(f x, mapbt(f, y), mapbt(f, z)) 

  ]

(** This AFS is converted to an AFSM simply by replacINg all free variables by meta-variables (with arity 0). **) 

 

  Interpretation: [

    J(branch) = Lam[y0;y1;y2].3 ; 
    J(leaf) = Lam[y0].3 ; 
    J(mapbt) = Lam[G0;y1].3*y1 + G0(y1) + 3*y1*G0(y1) 

  ]

(**

  [[mapbt(_F0, leaf(_x1))]] = 12 + 4*x1 + F0(0) + 3*x1*F0(3 + x1) + 10*F0(3 + x1) > 3 + x1 + F0(x1) = [[leaf(_F0 _x1)]] 
  [[mapbt(_F0, branch(_x1, _x2, _x3))]] = 12 + 4*x1 + 4*x2 + 4*x3 + F0(0) + 3*x1*F0(3 + x1 + x2 + x3) + 3*x2*F0(3 + x1 + x2 + x3) + 3*x3*F0(3 + x1 + x2 + x3) + 10*F0(3 + x1 + x2 + x3) > 3 + x1 + 4*x2 + 4*x3 + F0(x1) + F0(x2) + F0(x3) + 2*F0(0) + 3*x2*F0(x2) + 3*x3*F0(x3) = [[branch(_F0 _x1, mapbt(_F0, _x2), mapbt(_F0, _x3))]] 

**)

Removed: [

  mapbt(F, leaf(X)) => leaf(F X) ; 
  mapbt(F, branch(X, Y, Z)) => branch(F X, mapbt(F, Y), mapbt(F, Z)) 

]

